Binary Search

** Brute Force: TC: O(n) -- SC: O(1)
int search(vector<int>& nums, int target) {
    for(int i=0;i<nums.size();i++)
    {
        if(nums[i]==target){
            return i;
        }
    }
    return -1;
}

** Optimized: TC: O(logn) -- SC: O(1)
int search(vector<int>& nums, int target) {
    int start=0;
    int end=nums.size()-1;
    int mid;
    while (start <= end)
    {
        mid = start + (end-start)/ 2;

        if (nums[mid] == target)
            return mid ;

        else if (nums[mid] < target)
            start = mid + 1;

        else
            end = mid - 1;
    }

    return -1;
}
===============================================================

Implement Lower Bound :
    x gretaer than or equal to target (>=)

#include <bits/stdc++.h>
int lowerBound(vector<int> arr, int n, int x) {
	return lower_bound(arr.begin(),arr.end(),x)-arr.begin();
}

int lowerBound(vector<int> arr, int n, int x) {
	// Write your code here
	int low=0;int high=n-1;
	int ans=n;int mid;
	while(low<=high){
		mid = low + (high-low)/ 2;

		if(arr[mid]>=x){
			ans=mid;
			high=mid-1;
		}else{
			low=mid+1;
		}
	}
	return ans;
}

===============================================================

Implement Upper Bound
    x greater than target (>)


int upperBound(vector<int> &arr, int x, int n) {
    int low = 0, high = n - 1, mid;
    int ans = n;  // Initialize ans to n as a default

    while (low <= high) {
        mid = (high + low) / 2;

        if (arr[mid] > x) {
            ans = mid;       // Potential answer found
            high = mid - 1;  // Search left half
        } else {
            low = mid + 1;   // Search right half
        }
    }

    return ans;
}
===============================================================
	
Search Insert Position

int idx = lower_bound(nums.begin(), nums.end(), target) - nums.begin();

===============================================================

Floor/Ceil in Sorted Array

int floor(vector<int> &nums, int target) {
    int low = 0, high = nums.size() - 1, mid;
    int ans = -1;

    while (low <= high) {
        mid = low + (high - low) / 2;

        if (nums[mid] <= target) {
            ans = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return ans;
}

int ceil(vector<int> &nums, int target) {
    int low = 0, high = nums.size() - 1, mid;
    int ans = -1;

    while (low <= high) {
        mid = low + (high - low) / 2;

        if (nums[mid] >= target) {
            ans = mid;
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }

    return ans;
}

pair<int, int> getFloorAndCeil(vector<int> &a, int n, int x) {
    int floorAns = floor(a, x);
    int ceilAns = ceil(a, x);

    return {a[floorAns], a[ceilAns]};
}
===============================================================

===============================================================

===============================================================
33. Search in Rotated Sorted Array

** Brute Force: TC: O(n) -- SC: O(1)

    int search(vector<int>& nums, int target) {
        for(int i=0;i<nums.size();i++){
            if(nums[i]==target){
                return i;
            }
        }
        return -1;
    }

** Better Approach: TC: O(2* logn) -- SC: O(1)

    int bSearch(vector<int>& nums, int low, int high, int target){
        while(low<=high){
            int mid=low+(high-low)/2;
            
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]<target){
                low=mid+1;
            }else{
                high=mid-1;
            }
        }
        return -1;
    }
    int search(vector<int>& nums, int target) {
        int n=nums.size();
        int breakpoint;
        for(int i=1;i<n;i++){
            if(nums[i]<nums[i-1]){
                breakpoint=i;
                break;
            }
        }
        int low1=0, high1=breakpoint-1;
        int low2=breakpoint, high2=n-1;
        
        int ans1=bSearch(nums,low1,high1,target);
        int ans2=bSearch(nums,low2,high2,target);

        if(ans1!=-1){
            return ans1;
        }else if(ans2!=-1){
            return ans2;
        }    
        return -1;
    }

** Optimal Approach: TC: O(logn) -- SC: O(1)




===============================================================
===============================================================
===============================================================
===============================================================
