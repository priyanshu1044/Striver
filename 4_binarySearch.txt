Binary Search

** Brute Force: TC: O(n) -- SC: O(1)
int search(vector<int>& nums, int target) {
    for(int i=0;i<nums.size();i++)
    {
        if(nums[i]==target){
            return i;
        }
    }
    return -1;
}

** Optimized: TC: O(logn) -- SC: O(1)
int search(vector<int>& nums, int target) {
    int start=0;
    int end=nums.size()-1;
    int mid;
    while (start <= end)
    {
        mid = start + (end-start)/ 2;

        if (nums[mid] == target)
            return mid ;

        else if (nums[mid] < target)
            start = mid + 1;

        else
            end = mid - 1;
    }

    return -1;
}
===============================================================

Implement Lower Bound :
    x gretaer than or equal to target (>=)

#include <bits/stdc++.h>
int lowerBound(vector<int> arr, int n, int x) {
	return lower_bound(arr.begin(),arr.end(),x)-arr.begin();
}

int lowerBound(vector<int> arr, int n, int x) {
	// Write your code here
	int low=0;int high=n-1;
	int ans=n;int mid;
	while(low<=high){
		mid = low + (high-low)/ 2;

		if(arr[mid]>=x){
			ans=mid;
			high=mid-1;
		}else{
			low=mid+1;
		}
	}
	return ans;
}

===============================================================

Implement Upper Bound
    x greater than target (>)


int upperBound(vector<int> &arr, int x, int n) {
    int low = 0, high = n - 1, mid;
    int ans = n;  // Initialize ans to n as a default

    while (low <= high) {
        mid = (high + low) / 2;

        if (arr[mid] > x) {
            ans = mid;       // Potential answer found
            high = mid - 1;  // Search left half
        } else {
            low = mid + 1;   // Search right half
        }
    }

    return ans;
}
===============================================================
	
Search Insert Position

int idx = lower_bound(nums.begin(), nums.end(), target) - nums.begin();

===============================================================

Floor/Ceil in Sorted Array

int floor(vector<int> &nums, int target) {
    int low = 0, high = nums.size() - 1, mid;
    int ans = -1;

    while (low <= high) {
        mid = low + (high - low) / 2;

        if (nums[mid] <= target) {
            ans = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return ans;
}

int ceil(vector<int> &nums, int target) {
    int low = 0, high = nums.size() - 1, mid;
    int ans = -1;

    while (low <= high) {
        mid = low + (high - low) / 2;

        if (nums[mid] >= target) {
            ans = mid;
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }

    return ans;
}

pair<int, int> getFloorAndCeil(vector<int> &a, int n, int x) {
    int floorAns = floor(a, x);
    int ceilAns = ceil(a, x);

    return {a[floorAns], a[ceilAns]};
}
===============================================================
Find First and Last Position of Element in Sorted Array

** Brute Force: TC: O(n) -- SC: O(1)
    vector<int> searchRange(vector<int>& nums, int target) {
        int n=nums.size();
        int firstPosition=-1;
        int lastPosition=-1;
        for(int i=0;i<n;i++){
            if(nums[i]==target){
                if(firstPosition==-1) firstPosition=i;
                lastPosition = i;
            }
        }
        return {firstPosition,lastPosition};
    }

// // Better Solution
// // using lowerbound upperbound
// // lower bound= arr[i]>=x
// // upper bound= arr[i]>x
    int lowerbound(vector<int>& nums, int n, int target){
        int low=0,high=n-1,ans=n;
        
        while(low<=high){
            int mid=low+(high-low)/2;
            
            if(nums[mid]>=target){
                ans=mid;
                high=mid-1;
            }else{
                low=mid+1;
            }
        }
        
        return ans;
    }
    int upperbound(vector<int>& nums, int n, int target){
        int low=0,high=n-1,ans=n;
        
        while(low<=high){
            int mid=low+(high-low)/2;
            
            if(nums[mid]>target){
                ans=mid;
                high=mid-1;
            }else{
                low=mid+1;
            }
        }
        
        return ans;
    }
    vector<int> searchRange(vector<int>& nums, int target) {
        int n=nums.size();
        int lb=lowerbound(nums,n,target);
        int ub=upperbound(nums,n,target);
        if(lb>=n||nums[lb]!=target) {
            return {-1,-1};
        }
        return {lb,ub-1};
    }


===============================================================

Count occurrences of a number in a sorted array with duplicates

** Brute Force: TC: O(n) -- SC: O(1)
    int count(vector<int>& nums, int target) {
        int n=nums.size();
        int count=0;
        for(int i=0;i<n;i++){
            if(nums[i]==target){
                count++;
            }
        }
        return count;
    }

** Better Solution: TC: O(logn) -- SC: O(1)
    int lowerbound(vector<int>& nums, int n, int target){
        int low=0,high=n-1,ans=n;
        
        while(low<=high){
            int mid=low+(high-low)/2;
            
            if(nums[mid]>=target){
                ans=mid;
                high=mid-1;
            }else{
                low=mid+1;
            }
        }
        
        return ans;
    }
    int upperbound(vector<int>& nums, int n, int target){
        int low=0,high=n-1,ans=n;
        
        while(low<=high){
            int mid=low+(high-low)/2;
            
            if(nums[mid]>target){
                ans=mid;
                high=mid-1;
            }else{
                low=mid+1;
            }
        }
        
        return ans;
    }
    int count(vector<int>& nums, int target) {
        int n=nums.size();
        int lb=lowerbound(nums,n,target);
        int ub=upperbound(nums,n,target);
        return ub-lb;
    }

===============================================================
33. Search in Rotated Sorted Array

** Brute Force: TC: O(n) -- SC: O(1)

    int search(vector<int>& nums, int target) {
        for(int i=0;i<nums.size();i++){
            if(nums[i]==target){
                return i;
            }
        }
        return -1;
    }

** Better Approach: TC: O(2* logn) -- SC: O(1)

    int bSearch(vector<int>& nums, int low, int high, int target){
        while(low<=high){
            int mid=low+(high-low)/2;
            
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]<target){
                low=mid+1;
            }else{
                high=mid-1;
            }
        }
        return -1;
    }
    int search(vector<int>& nums, int target) {
        int n=nums.size();
        int breakpoint;
        for(int i=1;i<n;i++){
            if(nums[i]<nums[i-1]){
                breakpoint=i;
                break;
            }
        }
        int low1=0, high1=breakpoint-1;
        int low2=breakpoint, high2=n-1;
        
        int ans1=bSearch(nums,low1,high1,target);
        int ans2=bSearch(nums,low2,high2,target);

        if(ans1!=-1){
            return ans1;
        }else if(ans2!=-1){
            return ans2;
        }    
        return -1;
    }

** Optimal Approach: TC: O(logn) -- SC: O(1)

    int search(vector<int>& nums, int target) {
        int n=nums.size();
        int low=0,high=n-1,mid;

        while(low<=high){
            mid=low+(high-low)/2;
            if(nums[mid]==target){
                return mid;
            }
            // check that left part is sorted or not
            if(nums[low]<=nums[mid]){
                // check that target is lies in that part or not
                if(nums[low]<=target && target<=nums[mid]){
                    high=mid-1;
                }else{
                    low=mid+1;
                }
            // check that right part is sorted or not
            }else{
                if(nums[mid]<=target && target<=nums[high]){
                    low=mid+1;
                }else{
                    high=mid-1;
                }
            }
        }
        return -1;
    }


===============================================================
	
Search in Rotated Sorted Array II

** Brute Force: TC: O(n) -- SC: O(1)

    bool search(vector<int>& nums, int target) {
        for(int i=0;i<nums.size();i++){
            if(nums[i]==target){
                return true;
            }
        }
        return false;
    }

** Better Approach: TC: O(2* logn) -- SC: O(1)


===============================================================
===============================================================
===============================================================
